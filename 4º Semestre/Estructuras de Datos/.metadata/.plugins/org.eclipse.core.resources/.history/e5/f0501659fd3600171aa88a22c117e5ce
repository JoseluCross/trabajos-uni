package es.ubu.lsi.edat.pr10;

import java.util.ArrayList;
import java.util.List;
import java.util.Stack;

public class ArbolAVL<E> extends ArbolBB<E> {
	public int altura(E elemento) {
		List<Nodo> lista = buscar(super.raiz, elemento);
		Nodo supp = lista.get(0);
		if (supp == null) {
			return -1;
		}
		return alturaR(supp);
	}

	private int alturaR(Nodo nodo) {
		int alturaD = 0;
		int alturaI = 0;
		if (nodo.getDer() == null && nodo.getIzq() == null) {
			return 0;
		}
		if (nodo.getDer() == null) {
			alturaI = 1 + alturaR(nodo.getIzq());
		} else if (nodo.getIzq() == null) {
			alturaD = 1 + alturaR(nodo.getDer());
		} else {
			alturaI = 1 + alturaR(nodo.getIzq());
			alturaD = 1 + alturaR(nodo.getDer());
		}
		if (alturaD > alturaI) {
			return alturaD;
		}
		return alturaI;
	}

	public int profundidad(E elemento) {
		List<Nodo> lista = buscar(super.raiz, elemento);
		Nodo supp = lista.get(0);
		if (supp == null) {
			return -1;
		}
		if (lista.get(1) == null) {
			return 0;
		}
		return 1 + profundidad(lista.get(1).getDato());
	}

	@Override
	public boolean add(E elemento) {
		if (!super.add(elemento)) {
			return false;
		}
		Nodo padre = super.buscar(raiz, elemento).get(1);
		if(padre!=null)
			reequilibrioAVL(encontrarDes(padre));
		return true;
	}

	private Nodo encontrarDes(Nodo nodo) {
		int factor = comprobarAVL(nodo);
		if(factor == 2 || factor == -2)
			return nodo;
		else if(nodo==raiz)
			return null;
		else
			return encontrarDes(buscar(raiz,nodo.getDato()).get(1));
	}

	private int comprobarAVL(Nodo nodo) {
		int alturaD;
		int alturaI;
		if (nodo == null) {
			return 0;
		}

		if (nodo.getDer() == null) {
			alturaD = 0;
		} else {
			alturaD = 1 + altura(nodo.getDer().getDato());
		}
		if (nodo.getIzq() == null) {
			alturaI = 0;
		} else {
			alturaI = 1 + altura(nodo.getIzq().getDato());
		}
		return alturaD - alturaI;
	}

	private void reequilibrioAVL(Nodo nodo) {
		if (nodo != null) {
			int factor, derecho, izquierdo;
			factor = this.comprobarAVL(nodo);
			derecho = this.comprobarAVL(nodo.getDer());
			izquierdo = this.comprobarAVL(nodo.getIzq());
			switch (factor) {
			case 2:
				switch (derecho) {
				case 1:
				case 0:
					rotacionIzquierda(nodo);
					break;
				case -1:
					rotacionDerechaIzquierda(nodo);
					break;
				}
				break;
			case -2:
				switch (izquierdo) {
				case -1:
				case 0:
					rotacionDerecha(nodo);
					break;
				case 1:
					rotacionIzquierdaDerecha(nodo);
					break;
				}
				break;
			}
		}
	}

	private void rotacionIzquierda(Nodo nodo) {
		Nodo raizLocal;
		raizLocal = nodo.getDer();
		nodo.setDer(raizLocal.getIzq());
		raizLocal.setIzq(nodo);
		Nodo padre = buscar(super.raiz, nodo.getDato()).get(1);
		if (padre == null)
			super.raiz = raizLocal;
		else if (padre.getDer() == nodo)
			padre.setDer(raizLocal);
		else
			padre.setIzq(raizLocal);
	}

	private void rotacionDerecha(Nodo nodo) {
		Nodo raizLocal;
		raizLocal = nodo.getIzq();
		nodo.setIzq(raizLocal.getDer());
		raizLocal.setDer(nodo);
		Nodo padre = buscar(super.raiz, nodo.getDato()).get(1);
		if (padre == null)
			super.raiz = raizLocal;
		else if (padre.getDer() == nodo)
			padre.setDer(raizLocal);
		else
			padre.setIzq(raizLocal);
	}

	private void rotacionIzquierdaDerecha(Nodo nodo) {
		rotacionIzquierda(nodo.getIzq());
		rotacionDerecha(nodo);
	}

	private void rotacionDerechaIzquierda(Nodo nodo) {
		rotacionDerecha(nodo.getDer());
		rotacionIzquierda(nodo);
	}

	private void tratar(Stack<Integer> veces) {
		Integer elemento = veces.pop();
		elemento++;
		veces.push(elemento);
	}

	public List<E> preOrden() {
		List<E> retorno = new ArrayList<>(this.size());
		Stack<Integer> pila = new Stack<>();
		Stack<Nodo> pilaNodos = new Stack<>();
		pilaNodos.push(super.raiz);
		pila.push(1);
		while (pilaNodos.peek() != super.raiz || pila.peek() != 3) {
			Nodo cabeza = pilaNodos.peek();
			Integer veces = pila.peek();
			if (veces == 3) {
				pila.pop();
				pilaNodos.pop();
			} else if (veces == 1) {
				tratar(pila);
				retorno.add(cabeza.getDato());
				cabeza = cabeza.getIzq();
				if (cabeza != null) {
					pila.push(1);
					pilaNodos.push(cabeza);
				}
			} else {
				tratar(pila);
				cabeza = cabeza.getDer();
				if (cabeza != null) {
					pila.push(1);
					pilaNodos.push(cabeza);
				}
			}
		}

		return retorno;
	}

	public List<E> inOrden(boolean bool) {
		List<E> retorno = new ArrayList<>(this.size());
		Stack<Integer> pila = new Stack<>();
		Stack<Nodo> pilaNodos = new Stack<>();
		pilaNodos.push(super.raiz);
		pila.push(1);
		while (pilaNodos.peek() != super.raiz || pila.peek() != 3) {
			Nodo cabeza = pilaNodos.peek();
			Integer veces = pila.peek();
			if (veces == 3) {
				pila.pop();
				pilaNodos.pop();
			} else if (veces == 1) {
				tratar(pila);
				cabeza = cabeza.getIzq();
				if (cabeza != null) {
					pila.push(1);
					pilaNodos.push(cabeza);
				}
			} else {
				tratar(pila);
				retorno.add(cabeza.getDato());
				cabeza = cabeza.getDer();
				if (cabeza != null) {
					pila.push(1);
					pilaNodos.push(cabeza);
				}
			}
		}

		return retorno;
	}

	public List<E> posOrden() {
		List<E> retorno = new ArrayList<>(this.size());
		Stack<Integer> pila = new Stack<>();
		Stack<Nodo> pilaNodos = new Stack<>();
		pilaNodos.push(super.raiz);
		pila.push(1);
		while (pilaNodos.peek() != super.raiz || pila.peek() != 3) {
			Nodo cabeza = pilaNodos.peek();
			Integer veces = pila.peek();
			if (veces == 3) {
				retorno.add(cabeza.getDato());
				pila.pop();
				pilaNodos.pop();
			} else if (veces == 1) {
				tratar(pila);
				cabeza = cabeza.getIzq();
				if (cabeza != null) {
					pila.push(1);
					pilaNodos.push(cabeza);
				}
			} else {
				tratar(pila);
				cabeza = cabeza.getDer();
				if (cabeza != null) {
					pila.push(1);
					pilaNodos.push(cabeza);
				}
			}
		}
		retorno.add(super.raiz.getDato());
		return retorno;
	}
	
	@Override
	public boolean remove(Object o){
		Nodo padre;
		try{
			padre = super.buscar(raiz, (E) o).get(1);
		}catch(ClassCastException ex){
			return false;
		}
		boolean retorno = super.remove(o);
		if(retorno){
			if(padre!=null)
				reequilibrioAVL(encontrarDes(padre));
			else
				reequilibrioAVL(raiz);
		}
		return retorno;
	}

}
